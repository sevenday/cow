package main

import (
	"bytes"
	"fmt"
	"net"
	"os"
	"strconv"
	"strings"
	"text/template"
	"time"
)

const (
	authRealm       = "cow proxy"
	authRawBodyTmpl = `<!DOCTYPE html>
<html>
	<head> <title>COW Proxy</title> </head>
	<body>
		<h1>407 Proxy authentication required</h1>
		<hr />
		Generated by <i>COW</i>
	</body>
</html>
`
)

type netAddr struct {
	ip   net.IP
	mask net.IPMask
}

var auth struct {
	required bool

	user   string
	passwd string
	ha1    string // used in request digest

	allowedClient []netAddr

	authed *TimeoutSet // cache authentication based on client ip

	template *template.Template
}

func parseAllowedClient(val string) {
	if val == "" {
		return
	}
	auth.required = true
	arr := strings.Split(val, ",")
	auth.allowedClient = make([]netAddr, len(arr))
	for i, v := range arr {
		s := strings.TrimSpace(v)
		ipAndMask := strings.Split(s, "/")
		if len(ipAndMask) > 2 {
			fmt.Println("allowedClient syntax error: client should be the form ip/nbitmask")
			os.Exit(1)
		}
		ip := net.ParseIP(ipAndMask[0])
		if ip == nil {
			fmt.Printf("allowedClient syntax error %s: ip address not valid\n", s)
			os.Exit(1)
		}
		var mask net.IPMask
		if len(ipAndMask) == 2 {
			nbit, err := strconv.Atoi(ipAndMask[1])
			if err != nil {
				fmt.Printf("allowedClient syntax error %s: %v\n", s, err)
				os.Exit(1)
			}
			if nbit > 32 {
				fmt.Println("allowedClient error: mask number should <= 32")
				os.Exit(1)
			}
			mask = NewNbitIPv4Mask(nbit)
		} else {
			mask = NewNbitIPv4Mask(32)
		}
		auth.allowedClient[i] = netAddr{ip.Mask(mask), mask}
	}
}

func parseUserPasswd(val string) {
	if val == "" {
		return
	}
	auth.required = true
	// password format checking is done in checkConfig in config.go
	arr := strings.SplitN(val, ":", 2)
	auth.user, auth.passwd = arr[0], arr[1]
}

func initAuth() {
	parseUserPasswd(config.UserPasswd)
	parseAllowedClient(config.AllowedClient)

	if !auth.required {
		return
	}

	auth.authed = NewTimeoutSet(time.Duration(config.AuthTimeout) * time.Hour)

	if auth.user == "" {
		return
	}
	auth.ha1 = md5sum(auth.user + ":" + authRealm + ":" + auth.passwd)
	rawTemplate := "HTTP/1.1 407 Proxy Authentication Required\r\n" +
		"Proxy-Authenticate: Digest realm=\"" + authRealm + "\", nonce=\"{{.Nonce}}\", qop=\"auth\"\r\n" +
		"Content-Type: text/html\r\n" +
		"Cache-Control: no-cache\r\n" +
		"Content-Length: " + fmt.Sprintf("%d", len(authRawBodyTmpl)) + "\r\n\r\n" + authRawBodyTmpl
	var err error
	if auth.template, err = template.New("auth").Parse(rawTemplate); err != nil {
		errl.Println("Internal error generating auth template:", err)
		os.Exit(1)
	}
}

// Return err = nil if authentication succeed. nonce would be not empty if
// authentication is needed, and should be passed back on subsequent call.
func Authenticate(conn *clientConn, r *Request) (err error) {
	clientIP, _ := splitHostPort(conn.RemoteAddr().String())
	if auth.authed.has(clientIP) {
		debug.Printf("%s has already authed\n", clientIP)
		return
	}
	if authIP(clientIP) { // IP is allowed
		return
	}
	// No user specified
	if auth.user == "" {
		sendErrorPage(conn, "403 Forbidden", "Access forbidden", "You are not allowed to use the proxy.")
		return errShouldClose
	}
	err = authUserPasswd(conn, r)
	if err == nil {
		auth.authed.add(clientIP)
	}
	return
}

// authIP checks whether the client ip address matches one in allowedClient.
// It uses a sequential search.
func authIP(clientIP string) bool {
	ip := net.ParseIP(clientIP)
	if ip == nil {
		panic("authIP should always get IP address")
	}

	for _, na := range auth.allowedClient {
		if ip.Mask(na.mask).Equal(na.ip) {
			debug.Printf("client ip %s allowed\n", clientIP)
			return true
		}
	}
	return false
}

func genNonce() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%x", time.Now().Unix())
	return buf.String()
}

func calcRequestDigest(kv map[string]string, ha1, method string) string {
	// Refer to rfc2617 section 3.2.2.1 Request-Digest
	buf := bytes.NewBufferString(ha1)
	buf.WriteByte(':')
	buf.WriteString(kv["nonce"])
	buf.WriteByte(':')
	buf.WriteString(kv["nc"])
	buf.WriteByte(':')
	buf.WriteString(kv["cnonce"])
	buf.WriteByte(':')
	buf.WriteString("auth") // qop value
	buf.WriteByte(':')
	buf.WriteString(md5sum(method + ":" + kv["uri"]))

	return md5sum(buf.String())
}

func checkProxyAuthorization(r *Request) error {
	debug.Println("authorization:", r.ProxyAuthorization)
	arr := strings.SplitN(r.ProxyAuthorization, " ", 2)
	if len(arr) != 2 {
		errl.Println("auth: malformed ProxyAuthorization header:", r.ProxyAuthorization)
		return errBadRequest
	}
	if strings.ToLower(strings.TrimSpace(arr[0])) != "digest" {
		errl.Println("auth: client using unsupported authenticate method:", arr[0])
		return errBadRequest
	}
	authHeader := parseKeyValueList(arr[1])
	if len(authHeader) == 0 {
		errl.Println("auth: empty authorization list")
		return errBadRequest
	}
	nonceTime, err := strconv.ParseInt(authHeader["nonce"], 16, 64)
	if err != nil {
		return err
	}
	// If nonce time too early, reject. iOS will create a new connection to do
	// authenticate.
	if time.Now().Sub(time.Unix(nonceTime, 0)) > time.Minute {
		return errAuthRequired
	}
	if authHeader["username"] != auth.user {
		errl.Println("auth: username mismatch:", authHeader["username"])
		return errAuthRequired
	}
	if authHeader["qop"] != "auth" {
		errl.Println("auth: qop wrong:", authHeader["qop"])
		return errBadRequest
	}
	response, ok := authHeader["response"]
	if !ok {
		errl.Println("auth: no request-digest")
		return errBadRequest
	}

	digest := calcRequestDigest(authHeader, auth.ha1, r.Method)
	if response == digest {
		return nil
	}
	errl.Println("auth: digest not match, maybe password wrong")
	return errAuthRequired
}

func authUserPasswd(conn *clientConn, r *Request) (err error) {
	if r.ProxyAuthorization != "" {
		// client has sent authorization header
		err = checkProxyAuthorization(r)
		if err == nil {
			return
		} else if err != errAuthRequired {
			sendErrorPage(conn, errCodeBadReq, "Bad authorization request", "")
			return
		}
	}

	nonce := genNonce()
	data := struct {
		Nonce string
	}{
		nonce,
	}
	buf := new(bytes.Buffer)
	if err := auth.template.Execute(buf, data); err != nil {
		errl.Println("Error generating auth response:", err)
		return errInternal
	}
	if debug {
		debug.Printf("authorization response:\n%s", buf.String())
	}
	if _, err := conn.Write(buf.Bytes()); err != nil {
		errl.Println("Sending auth response error:", err)
		return errShouldClose
	}
	return errAuthRequired
}
